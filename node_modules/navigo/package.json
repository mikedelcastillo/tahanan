{
  "_args": [
    [
      {
        "raw": "navigo",
        "scope": null,
        "escapedName": "navigo",
        "name": "navigo",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "/Users/mikedelcastillo/Code/Github/tahanan"
    ]
  ],
  "_from": "navigo@latest",
  "_id": "navigo@7.1.1",
  "_inCache": true,
  "_location": "/navigo",
  "_nodeVersion": "6.11.4",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/navigo_7.1.1_1518113698006_0.9027786184231268"
  },
  "_npmUser": {
    "name": "krasimir",
    "email": "krasimir@outset.ws"
  },
  "_npmVersion": "3.10.10",
  "_phantomChildren": {},
  "_requested": {
    "raw": "navigo",
    "scope": null,
    "escapedName": "navigo",
    "name": "navigo",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/navigo/-/navigo-7.1.1.tgz",
  "_shasum": "c7e3eb4398125769f3bc6b7c924d8139da466038",
  "_shrinkwrap": null,
  "_spec": "navigo",
  "_where": "/Users/mikedelcastillo/Code/Github/tahanan",
  "author": {
    "name": "Krasimir Tsonev",
    "email": "info@krasimirtsonev.com",
    "url": "http://krasimirtsonev.com"
  },
  "browser": "lib/navigo.min.js",
  "bugs": {
    "url": "https://github.com/krasimir/navigo/issues"
  },
  "dependencies": {},
  "description": "A simple vanilla JavaScript router with a fallback for older browsers",
  "devDependencies": {
    "babel": "6.23.0",
    "babel-core": "6.26.0",
    "babel-eslint": "8.2.1",
    "babel-plugin-add-module-exports": "0.2.1",
    "babel-preset-es2015": "6.24.1",
    "babel-preset-stage-1": "6.24.1",
    "babelify": "8.0.0",
    "browserify": "16.0.0",
    "chai": "4.1.2",
    "eslint": "4.17.0",
    "karma": "2.0.0",
    "karma-browserify": "5.1.3",
    "karma-chrome-launcher": "2.2.0",
    "karma-firefox-launcher": "1.1.0",
    "karma-mocha": "1.3.0",
    "karma-mocha-reporter": "2.2.5",
    "karma-phantomjs-launcher": "1.0.4",
    "karma-source-map-support": "1.2.0",
    "mocha": "5.0.0",
    "rollup": "^0.55.3",
    "rollup-plugin-babel": "^3.0.3",
    "rollup-plugin-uglify": "^3.0.0",
    "sinon": "4.2.2",
    "sinon-chai": "2.14.0",
    "watchify": "3.10.0"
  },
  "directories": {},
  "dist": {
    "shasum": "c7e3eb4398125769f3bc6b7c924d8139da466038",
    "tarball": "https://registry.npmjs.org/navigo/-/navigo-7.1.1.tgz",
    "fileCount": 44,
    "unpackedSize": 603686
  },
  "gitHead": "784277483946e4f1eb74ddcfe94d5038e1ef0e8e",
  "homepage": "https://github.com/krasimir/navigo#readme",
  "jsnext:main": "lib/navigo.es.js",
  "keywords": [
    "router",
    "vanilla",
    "hash",
    "history"
  ],
  "license": "MIT",
  "main": "lib/navigo.cjs.js",
  "maintainers": [
    {
      "name": "krasimir",
      "email": "krasimir@outset.ws"
    }
  ],
  "module": "lib/navigo.es.js",
  "name": "navigo",
  "optionalDependencies": {},
  "readme": "# Navigo\n\nA simple minimalistic JavaScript router with a fallback for older browsers.\n\n![Travis](https://travis-ci.org/krasimir/navigo.svg?branch=master)\n[![npm downloads](https://img.shields.io/npm/dm/navigo.svg?style=flat-square)](https://www.npmjs.com/package/navigo)\n\n*([Demo source files](./demo))*\n\n---\n\n## Installation\n\nDrop the following into your page:\n\n```html\n<script src=\"//unpkg.com/navigo@6\"></script>\n``` \n\nor use via npm:\n\n```bash\nnpm install navigo --save\n```\n\n## Usage\n\n### Initialization\n\n```js\nvar root = null;\nvar useHash = true; // Defaults to: false\nvar hash = '#!'; // Defaults to: '#'\nvar router = new Navigo(root, useHash, hash);\n```\n\nThe constructor of the library accepts three argument - `root`, `useHash` and `hash`. The first one is the main URL of\nyour application. If you call the constructor without parameters then Navigo figures out the root URL based on your routes. However, this proves to lead to bugs so I strongly recommend to set a `root` value.\n\nIf `useHash` set to `true` then the router uses an old routing approach with hash in the URL. Navigo anyways falls back\nto this mode if there is no History API supported. The `hash` parameter allows you to configure the hash character. To\nmake your URLs crawlable by Google you should use use '#!'. Read more at [developers.google.com](https://developers.google.com/webmasters/ajax-crawling/docs/learn-more).\n\n### Adding a route\n\n```js\nrouter\n  .on('/products/list', function () {\n    // display all the products\n  })\n  .resolve();\n```\n\n### Adding a main/root handler\n\n```js\nrouter\n  .on(function () {\n    // show home page here\n  })\n  .resolve();\n```\n\n### Adding multiple routes\n\n```js\nrouter\n  .on({\n    'products/:id': function () {\n      setContent('Products');\n    },\n    'products': function () {\n      setContent('About');\n    },\n    '*': function () {\n      setContent('Home')\n    }\n  })\n  .resolve();\n```\n\n*Have in mind that the order of the added routes using this method [does not](https://github.com/krasimir/navigo/pull/39) matter anymore. However, if we add series of routes by calling `on` multiple times we should consider the order of the calls.*\n\n### Parameterized URLs:\n\n```js\nrouter\n  .on('/user/:id/:action', function (params) {\n    // If we have http://site.com/user/42/save as a url then\n    // params.id = 42\n    // params.action = save\n  })\n  .resolve();\n```\n\n### Accessing GET parameters\n\nEvery handler receives the GET parameters passed to the page.\n\n```js\nrouter\n  .on('/user/:id/:action', function (params, query) {\n    // If we have http://site.com/user/42/save?answer=42 as a url then\n    // params.id = 42\n    // params.action = save\n    // query = answer=42\n  })\n  .resolve();\n```\n\nIn the case of the default handler and `notFound` handler the function receives only `query` as parameter. For example:\n```js\nrouter.notFound(function (query) {\n  // ...\n});\n```\n\n### Using regular expression\n\n```js\nrouter\n  .on(/users\\/(\\d+)\\/(\\w+)\\/?/, function (id, action) {\n    // If we have http://site.com/user/42/save as a url then\n    // id = 42\n    // action = save\n  })\n  .resolve();\n```\n\nWild card is also supported:\n\n```js\nrouter\n  .on('/user/*', function () {\n    // This function will be called on every\n    // URL that starts with /user\n  })\n  .resolve();\n```\n\n*Have in mind that every call of `on` do not trigger a route check (anymore). You have to run `resolve` method manually to get the routing works.*\n\n### Not-found handler\n\n```js\nrouter.notFound(function () {\n  // called when there is path specified but\n  // there is no route matching\n});\n```\n\n### Changing the page\n\nUse the `navigate` method:\n\n```js\nrouter.navigate('/products/list');\n```\n\nYou may also specify an absolute path. For example:\n\n```js\nrouter.navigate('http://site.com/products/list', true);\n```\n\nIf you want to bind page links to Navigo you have to add `data-navigo` attribute. For example:\n\n```html\n<a href=\"about\" data-navigo>About</a>\n```\n\n*(Have in mind that you have to fire `updatePageLinks` every time when new links are placed on the page so Navigo does the binding for them.)*\n\nIt's translated to:\n\n```js\n// the html to: <a href=\"javascript:void(0);\" data-navigo>About</a>\nvar location = link.getAttribute('href');\n...\nlink.addEventListener('click', e => {\n  e.preventDefault();\n  router.navigate(location);\n});\n```\n\n### Named routes\n\nUse the following API to give a name to your route and later generate URLs:\n\n```js\nrouter = new Navigo('http://site.com/', true);\nrouter.on({\n  '/trip/:tripId/edit': { as: 'trip.edit', uses: handler },\n  '/trip/save': { as: 'trip.save', uses: handler },\n  '/trip/:action/:tripId': { as: 'trip.action', uses: handler }\n});\nconsole.log(router.generate('trip.edit', { tripId: 42 })); // --> /trip/42/edit\nconsole.log(router.generate('trip.action', { tripId: 42, action: 'save' })); // --> /trip/save/42\nconsole.log(router.generate('trip.save')); // --> /trip/save\n```\n\n### Resolving the routes\n\nThe resolving of the routes happen when `resolve` method is fired which happen:\n\n* if you manually run `router.resolve()`\n* every time when the page's URL changes\n* if you call `navigate`\n\n### Pausing the router\n\n[Sometimes](https://github.com/krasimir/navigo/issues/18) you need to update the URL but you don't want to resolve your callbacks. In such cases you may call `.pause()` and do `.navigate('new/url/here')`. For example:\n\n```js\nr.pause();\nr.navigate('/en/products');\nr.resume(); // or .pause(false)\n```\n\nThe route will be changed to `/en/products` but if you have a handler for that path will not be executed.\n\n### Hooks\n\nThere is an API that allows you to run functions before firing a route handler. The `hooks` object is in the format of:\n\n```js\n{\n  before: function (done, params) { ... done(); },\n  after: function (params) { ... },\n  leave: function (params) { ... },\n  already: function (params) { ... }\n}\n```\n\nYou may specify only one of the hooks. The `before` hook accepts a function which you *must* invoke once you finish your job. Here is an examples:\n\n```js\nrouter.on(\n  '/user/edit',\n  function () {\n    // show user edit page\n  },\n  {\n    before: function (done, params) {\n      // doing some async operation\n      done();\n    },\n    after: function (params) {\n      // after resolving\n    },\n    leave: function (params) {\n      // when you are going out of the that route\n    }\n  }\n);\n```\n\nYou may prevent the handler to be resolved in the `before` hook by invoking `done(false)`:\n\n```js\nrouter.on(\n  '/user/edit',\n  function () {\n    // show user edit page\n  },\n  {\n    before: function (done, params) {\n      if(!user.loggedIn) {\n        done(false);\n      } else {\n        done()\n      }\n    }\n  }\n);\n```\n\nYou may provide hooks in two other cases:\n\n* While specifying a main/root handler `router.on(function() { ... }, hooks)`\n* While specifying a not-found page handler `router.notFound(function() { ... }, hooks)`\n\n#### Generic hooks\n\nIt is possible to set a `before` and/or `after` hooks for all the routes:\n\n```js\nvar router = new Navigo();\nrouter.hooks({\n  before: function(done, params) { ... },\n  after: function(params) { ... }\n});\n```\n\n*Also notice that both hooks receive `params` in case they are attached to a parameterized route.*\n\n## API\n\n* `router.on(function)` - adding handler for root/main route\n* `router.on(string, function)` - adding a new route\n* `router.on(object)` - adding a new route\n* `router.off(handler)` - removes the routes associated with the given handler/function\n* `router.navigate(path='', absolute=false)` - if `absolute` is `false` then Navigo finds the root path of your app based on the provided routes.\n* `router.resolve(currentURL=undefined)` - if `currentURL` is provided then the method tries resolving the registered routes to that URL and not `window.location.href`.\n* `router.destroy` - removes all the registered routes and stops the URL change listening.\n* `router.link(path)` - it returns a full url of the given `path`\n* `router.pause(boolean)` - it gives you a chance to change the route without resolving. Make sure that you call `router.pause(false)` so you return to the previous working state.\n* `router.disableIfAPINotAvailable()` - well, it disables the route if History API is not supported\n* `router.updatePageLinks()` - it triggers the `data-navigo` links binding process\n* `router.notFound(function)` - adding a handler for not-found URL (404 page)\n* `router.lastRouteResolved()` - returns an object with the format of `{ url: <string>, query: <string> }` matching the latest resolved route\n* `router.getLinkPath` - you may overwrite that function to provide a different mechanism for fetching paths from links which are currently on the page (with `data-navigo` attribute)\n* `router.historyAPIUpdateMethod` - by default Navigo uses History.pushState and changes that to History.replaceState if the router is `pause`d. If you need to always use `pushState` even if the router is `pause`d use this method like `router.historyAPIUpdateMethod('pushState')` after calling `pause`.\n\nThere are couple of static properties. You'll probably never need to touch them but here're they:\n\n```js\nNavigo.PARAMETER_REGEXP = /([:*])(\\w+)/g;\nNavigo.WILDCARD_REGEXP = /\\*/g;\nNavigo.REPLACE_VARIABLE_REGEXP = '([^\\/]+)';\nNavigo.REPLACE_WILDCARD = '(?:.*)';\nNavigo.FOLLOWED_BY_SLASH_REGEXP = '(?:\\/$|$)';\nNavigo.MATCH_REGEXP_FLAGS = '';\n```\n\n`Navigo.MATCH_REGEXP_FLAGS` could be useful when you want a case insensitive route matching. Simple use `Navigo.MATCH_REGEXP_FLAGS = 'i'`.\n\n## Tests\n\n```\nnpm i\nnpm test\n// or npm run test-chrome\n// or npm run test-firefox\n```\n\n## Inspiration\n\n* [A modern JavaScript router in 100 lines](http://krasimirtsonev.com/blog/article/A-modern-JavaScript-router-in-100-lines-history-api-pushState-hash-url)\n\n## TODO\n\n* A general handler for when Navigo matches some of the rules\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/krasimir/navigo.git"
  },
  "scripts": {
    "build": "npm run build:dev && npm run build:prod",
    "build:dev": "rollup -c rollup.config.js --environment BUILD:development",
    "build:prod": "rollup -c rollup.config.js --environment BUILD:production",
    "release": "npm run build && npm run test",
    "test": "node ./test/karma.js",
    "test-chrome": "node ./test/karma.js --browser=Chrome --watch=true",
    "test-firefox": "node ./test/karma.js --browser=Firefox  --watch=true",
    "watch": "rollup -c -w rollup.config.js --environment BUILD:development"
  },
  "version": "7.1.1"
}
